"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const client_s3_1 = require("@aws-sdk/client-s3");
const csvParser = require("fast-csv");
const path = require("path");
const s3 = new client_s3_1.S3Client({});
const BUCKET_NAME = process.env.BUCKET_NAME || '';
const METADATA_FILE_KEY = 'metadata/metadata.csv'; // Fixed location for metadata.csv
/**
 * Helper function to read the content of an S3 object.
 */
async function getObject(bucket, key) {
    const command = new client_s3_1.GetObjectCommand({ Bucket: bucket, Key: key });
    const response = await s3.send(command);
    const stream = response.Body;
    return new Promise((resolve, reject) => {
        let data = '';
        stream.on('data', chunk => (data += chunk));
        stream.on('end', () => resolve(data));
        stream.on('error', err => reject(err));
    });
}
/**
 * Helper function to upload content to S3.
 */
async function putObject(bucket, key, data) {
    const command = new client_s3_1.PutObjectCommand({
        Bucket: bucket,
        Key: key,
        Body: data,
        ContentType: 'text/csv',
    });
    await s3.send(command);
}
/**
 * AWS Lambda handler to process S3 events.
 */
const handler = async (event) => {
    for (const record of event.Records) {
        const audioFileKey = record.s3.object.key;
        // Metadata extraction: filename, upload timestamp, and client ID
        const newMetadata = {
            FileName: path.basename(audioFileKey), // Extract filename
            UploadTimestamp: new Date().toISOString(), // Upload timestamp
            ClientID: getClientID(audioFileKey), // Extract client ID from the file path
        };
        let rows = [];
        const headers = ['FileName', 'UploadTimestamp', 'ClientID'];
        // Fetch existing metadata.csv file, if it exists
        try {
            const metadataCsv = await getObject(BUCKET_NAME, METADATA_FILE_KEY);
            // Parse existing CSV content
            await new Promise((resolve, reject) => {
                csvParser
                    .parseString(metadataCsv, { headers: true })
                    .on('data', row => {
                    // Only add valid rows
                    if (row.FileName && row.UploadTimestamp && row.ClientID) {
                        rows.push(row);
                    }
                })
                    .on('end', resolve)
                    .on('error', reject);
            });
        }
        catch (err) {
            if (err.name === 'NoSuchKey') {
                console.log('metadata.csv does not exist yet. Creating a new file.');
            }
            else {
                console.error('Error fetching metadata.csv:', err);
                throw err;
            }
        }
        // Check for duplicates and append new metadata
        const isDuplicate = rows.some(row => row.FileName === newMetadata.FileName &&
            row.UploadTimestamp === newMetadata.UploadTimestamp &&
            row.ClientID === newMetadata.ClientID);
        if (!isDuplicate) {
            rows.push(newMetadata);
        }
        // Convert rows to CSV format with fixed headers
        const csvStream = csvParser.format({ headers });
        const output = [];
        csvStream.on('data', chunk => output.push(chunk.toString()));
        rows.forEach(row => csvStream.write(row));
        csvStream.end();
        // Upload the updated metadata.csv to S3
        const updatedCsv = output.join('');
        await putObject(BUCKET_NAME, METADATA_FILE_KEY, updatedCsv);
        console.log(`Metadata updated for file: ${audioFileKey}`);
    }
};
exports.handler = handler;
/**
 * Helper function to extract client ID from the file path.
 */
function getClientID(filePath) {
    // Assuming the client ID is part of the file path, e.g., "audiofiles/client1/filename.mp3"
    const parts = filePath.split('/');
    return parts.length > 1 ? parts[1] : 'UnknownClient';
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxrREFBa0Y7QUFHbEYsc0NBQXNDO0FBQ3RDLDZCQUE2QjtBQUU3QixNQUFNLEVBQUUsR0FBRyxJQUFJLG9CQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDNUIsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDO0FBQ2xELE1BQU0saUJBQWlCLEdBQUcsdUJBQXVCLENBQUMsQ0FBQyxrQ0FBa0M7QUFFckY7O0dBRUc7QUFDSCxLQUFLLFVBQVUsU0FBUyxDQUFDLE1BQWMsRUFBRSxHQUFXO0lBQ2xELE1BQU0sT0FBTyxHQUFHLElBQUksNEJBQWdCLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ25FLE1BQU0sUUFBUSxHQUFHLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN4QyxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsSUFBZ0IsQ0FBQztJQUV6QyxPQUFPLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFO1FBQ3JDLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUNkLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQztRQUM1QyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN0QyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBQ3pDLENBQUMsQ0FB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RCxnREFBZ0Q7UUFDaEQsTUFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDaEQsTUFBTSxNQUFNLEdBQWEsRUFBRSxDQUFDO1FBQzVCLFNBQVMsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDMUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBRWhCLHdDQUF3QztRQUN4QyxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ25DLE1BQU0sU0FBUyxDQUFDLFdBQVcsRUFBRSxpQkFBaUIsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUU1RCxPQUFPLENBQUMsR0FBRyxDQUFDLDhCQUE4QixZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQzVELENBQUM7QUFDSCxDQUFDLENBQUM7QUFqRVcsUUFBQSxPQUFPLFdBaUVsQjtBQUVGOztHQUVHO0FBQ0gsU0FBUyxXQUFXLENBQUMsUUFBZ0I7SUFDbkMsMkZBQTJGO0lBQzNGLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDbEMsT0FBTyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUM7QUFDdkQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFMzQ2xpZW50LCBHZXRPYmplY3RDb21tYW5kLCBQdXRPYmplY3RDb21tYW5kIH0gZnJvbSAnQGF3cy1zZGsvY2xpZW50LXMzJztcbmltcG9ydCB7IFMzRXZlbnQgfSBmcm9tICdhd3MtbGFtYmRhJztcbmltcG9ydCB7IFJlYWRhYmxlIH0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCAqIGFzIGNzdlBhcnNlciBmcm9tICdmYXN0LWNzdic7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5jb25zdCBzMyA9IG5ldyBTM0NsaWVudCh7fSk7XG5jb25zdCBCVUNLRVRfTkFNRSA9IHByb2Nlc3MuZW52LkJVQ0tFVF9OQU1FIHx8ICcnO1xuY29uc3QgTUVUQURBVEFfRklMRV9LRVkgPSAnbWV0YWRhdGEvbWV0YWRhdGEuY3N2JzsgLy8gRml4ZWQgbG9jYXRpb24gZm9yIG1ldGFkYXRhLmNzdlxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byByZWFkIHRoZSBjb250ZW50IG9mIGFuIFMzIG9iamVjdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0T2JqZWN0KGJ1Y2tldDogc3RyaW5nLCBrZXk6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gIGNvbnN0IGNvbW1hbmQgPSBuZXcgR2V0T2JqZWN0Q29tbWFuZCh7IEJ1Y2tldDogYnVja2V0LCBLZXk6IGtleSB9KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzMy5zZW5kKGNvbW1hbmQpO1xuICBjb25zdCBzdHJlYW0gPSByZXNwb25zZS5Cb2R5IGFzIFJlYWRhYmxlO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgbGV0IGRhdGEgPSAnJztcbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBjaHVuayA9PiAoZGF0YSArPSBjaHVuaykpO1xuICAgIHN0cmVhbS5vbignZW5kJywgKCkgPT4gcmVzb2x2ZShkYXRhKSk7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGVyciA9PiByZWplY3QoZXJyKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byB1cGxvYWQgY29udGVudCB0byBTMy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHV0T2JqZWN0KGJ1Y2tldDogc3RyaW5nLCBrZXk6IHN0cmluZywgZGF0YTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IGNvbW1hbmQgPSBuZXcgUHV0T2JqZWN0Q29tbWFuZCh7XG4gICAgQnVja2V0OiBidWNrZXQsXG4gICAgS2V5OiBrZXksXG4gICAgQm9keTogZGF0YSxcbiAgICBDb250ZW50VHlwZTogJ3RleHQvY3N2JyxcbiAgfSk7XG4gIGF3YWl0IHMzLnNlbmQoY29tbWFuZCk7XG59XG5cbi8qKlxuICogQVdTIExhbWJkYSBoYW5kbGVyIHRvIHByb2Nlc3MgUzMgZXZlbnRzLlxuICovXG5leHBvcnQgY29uc3QgaGFuZGxlciA9IGFzeW5jIChldmVudDogUzNFdmVudCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBmb3IgKGNvbnN0IHJlY29yZCBvZiBldmVudC5SZWNvcmRzKSB7XG4gICAgY29uc3QgYXVkaW9GaWxlS2V5ID0gcmVjb3JkLnMzLm9iamVjdC5rZXk7XG5cbiAgICAvLyBNZXRhZGF0YSBleHRyYWN0aW9uOiBmaWxlbmFtZSwgdXBsb2FkIHRpbWVzdGFtcCwgYW5kIGNsaWVudCBJRFxuICAgIGNvbnN0IG5ld01ldGFkYXRhID0ge1xuICAgICAgRmlsZU5hbWU6IHBhdGguYmFzZW5hbWUoYXVkaW9GaWxlS2V5KSwgLy8gRXh0cmFjdCBmaWxlbmFtZVxuICAgICAgVXBsb2FkVGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksIC8vIFVwbG9hZCB0aW1lc3RhbXBcbiAgICAgIENsaWVudElEOiBnZXRDbGllbnRJRChhdWRpb0ZpbGVLZXkpLCAvLyBFeHRyYWN0IGNsaWVudCBJRCBmcm9tIHRoZSBmaWxlIHBhdGhcbiAgICB9O1xuXG4gICAgbGV0IHJvd3M6IHsgRmlsZU5hbWU6IHN0cmluZzsgVXBsb2FkVGltZXN0YW1wOiBzdHJpbmc7IENsaWVudElEOiBzdHJpbmcgfVtdID0gW107XG4gICAgY29uc3QgaGVhZGVycyA9IFsnRmlsZU5hbWUnLCAnVXBsb2FkVGltZXN0YW1wJywgJ0NsaWVudElEJ107XG5cbiAgICAvLyBGZXRjaCBleGlzdGluZyBtZXRhZGF0YS5jc3YgZmlsZSwgaWYgaXQgZXhpc3RzXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1ldGFkYXRhQ3N2ID0gYXdhaXQgZ2V0T2JqZWN0KEJVQ0tFVF9OQU1FLCBNRVRBREFUQV9GSUxFX0tFWSk7XG5cbiAgICAgIC8vIFBhcnNlIGV4aXN0aW5nIENTViBjb250ZW50XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNzdlBhcnNlclxuICAgICAgICAgIC5wYXJzZVN0cmluZyhtZXRhZGF0YUNzdiwgeyBoZWFkZXJzOiB0cnVlIH0pXG4gICAgICAgICAgLm9uKCdkYXRhJywgcm93ID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHZhbGlkIHJvd3NcbiAgICAgICAgICAgIGlmIChyb3cuRmlsZU5hbWUgJiYgcm93LlVwbG9hZFRpbWVzdGFtcCAmJiByb3cuQ2xpZW50SUQpIHtcbiAgICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAub24oJ2VuZCcsIHJlc29sdmUpXG4gICAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnI6IGFueSkge1xuICAgICAgaWYgKGVyci5uYW1lID09PSAnTm9TdWNoS2V5Jykge1xuICAgICAgICBjb25zb2xlLmxvZygnbWV0YWRhdGEuY3N2IGRvZXMgbm90IGV4aXN0IHlldC4gQ3JlYXRpbmcgYSBuZXcgZmlsZS4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1ldGFkYXRhLmNzdjonLCBlcnIpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGR1cGxpY2F0ZXMgYW5kIGFwcGVuZCBuZXcgbWV0YWRhdGFcbiAgICBjb25zdCBpc0R1cGxpY2F0ZSA9IHJvd3Muc29tZShcbiAgICAgIHJvdyA9PlxuICAgICAgICByb3cuRmlsZU5hbWUgPT09IG5ld01ldGFkYXRhLkZpbGVOYW1lICYmXG4gICAgICAgIHJvdy5VcGxvYWRUaW1lc3RhbXAgPT09IG5ld01ldGFkYXRhLlVwbG9hZFRpbWVzdGFtcCAmJlxuICAgICAgICByb3cuQ2xpZW50SUQgPT09IG5ld01ldGFkYXRhLkNsaWVudElEXG4gICAgKTtcblxuICAgIGlmICghaXNEdXBsaWNhdGUpIHtcbiAgICAgIHJvd3MucHVzaChuZXdNZXRhZGF0YSk7XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCByb3dzIHRvIENTViBmb3JtYXQgd2l0aCBmaXhlZCBoZWFkZXJzXG4gICAgY29uc3QgY3N2U3RyZWFtID0gY3N2UGFyc2VyLmZvcm1hdCh7IGhlYWRlcnMgfSk7XG4gICAgY29uc3Qgb3V0cHV0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGNzdlN0cmVhbS5vbignZGF0YScsIGNodW5rID0+IG91dHB1dC5wdXNoKGNodW5rLnRvU3RyaW5nKCkpKTtcbiAgICByb3dzLmZvckVhY2gocm93ID0+IGNzdlN0cmVhbS53cml0ZShyb3cpKTtcbiAgICBjc3ZTdHJlYW0uZW5kKCk7XG5cbiAgICAvLyBVcGxvYWQgdGhlIHVwZGF0ZWQgbWV0YWRhdGEuY3N2IHRvIFMzXG4gICAgY29uc3QgdXBkYXRlZENzdiA9IG91dHB1dC5qb2luKCcnKTtcbiAgICBhd2FpdCBwdXRPYmplY3QoQlVDS0VUX05BTUUsIE1FVEFEQVRBX0ZJTEVfS0VZLCB1cGRhdGVkQ3N2KTtcblxuICAgIGNvbnNvbGUubG9nKGBNZXRhZGF0YSB1cGRhdGVkIGZvciBmaWxlOiAke2F1ZGlvRmlsZUtleX1gKTtcbiAgfVxufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZXh0cmFjdCBjbGllbnQgSUQgZnJvbSB0aGUgZmlsZSBwYXRoLlxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRJRChmaWxlUGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gQXNzdW1pbmcgdGhlIGNsaWVudCBJRCBpcyBwYXJ0IG9mIHRoZSBmaWxlIHBhdGgsIGUuZy4sIFwiYXVkaW9maWxlcy9jbGllbnQxL2ZpbGVuYW1lLm1wM1wiXG4gIGNvbnN0IHBhcnRzID0gZmlsZVBhdGguc3BsaXQoJy8nKTtcbiAgcmV0dXJuIHBhcnRzLmxlbmd0aCA+IDEgPyBwYXJ0c1sxXSA6ICdVbmtub3duQ2xpZW50Jztcbn1cbiJdfQ==